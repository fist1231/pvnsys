package com.pvnsys.ttts.engine.impl

import com.pvnsys.ttts.engine.messages.TttsEngineMessages
import com.typesafe.scalalogging.slf4j.LazyLogging
import com.pvnsys.ttts.engine.util.Utils

object FakeEngine {
}

/**
 * Example of some engine.
 * 
 */
class SimulatorEngine extends Engine with LazyLogging {

  import TttsEngineMessages._
  import Engine._

  var resultStatus = false

  override def process(msg: TttsEngineMessage, isInTrade: Boolean): EngineType = {
    
    /*
     * Do Engine processing, create ResponseEngineFacadeTopicMessage (reply to FacadeMS)
     * 
     */ 
    resultStatus = isInTrade

    
    // 1. Do some fake Engine processing here. Replace with real code.
//    val fraction = msg.asInstanceOf[ResponseEngineFacadeTopicMessage].payload.toDouble - msg.asInstanceOf[ResponseEngineFacadeTopicMessage].payload.toDouble.intValue
//    val signal = fraction match {
//      case x if(x < 0.2) => "BUY"
//      case x if(x > 0.8) => "SELL"
//      case _ => "HOLD"
//    }
    
    // 2. Create ResponseEngineFacadeTopicMessage

    // Generate unique message ID, timestamp and sequence number to be assigned to every message.
    val messageTraits = Utils.generateMessageTraits


    /*
     * - Assign unique message id and timestamp generated by Utils.generateMessageTraits.
     * - Pass along client, payload and sequenceNum from Engine message.
     * - Add signal field
     * - Return ResponseEngineFacadeTopicMessage or ResponseEngineServiceTopicMessage, depending on incoming message type.
     */ 
    msg match {
	    case x: ResponseStrategyFacadeTopicMessage => {
	       val payload = s"${x.payload} ==> ${play(x.signal)}"
	       (ResponseEngineFacadeTopicMessage(messageTraits._1, ENGINE_RESPONSE_MESSAGE_TYPE, x.client, payload, messageTraits._2, x.sequenceNum, x.signal), resultStatus)
	    }
	    case x: ResponseStrategyServicesTopicMessage => {
	       val payload = s"${x.payload} ==> ${play(x.signal)}"
	       (ResponseEngineServicesTopicMessage(messageTraits._1, ENGINE_RESPONSE_MESSAGE_TYPE, x.client, payload, messageTraits._2, x.sequenceNum, x.signal, x.serviceId), resultStatus)	      
	    }
	    case _ =>  {
	      logger.error("FakeEngine Received unsupported message type")
	      (msg, resultStatus)
	    }
    }

  }
  
  def play(signal: String) = {
    signal match {
      case "BUY" => if(!resultStatus) {
        resultStatus = true
        "BOUGHT"
      }
      case "SELL" => if(resultStatus) {
        resultStatus = false
        "SOLD"
      }
      case "HOLD" => "PASS"
      case _ => "Nothing"
    }
    
  }

}
  
