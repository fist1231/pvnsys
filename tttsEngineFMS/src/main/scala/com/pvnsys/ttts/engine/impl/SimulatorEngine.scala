package com.pvnsys.ttts.engine.impl

import com.pvnsys.ttts.engine.messages.TttsEngineMessages
import com.typesafe.scalalogging.slf4j.LazyLogging
import com.pvnsys.ttts.engine.util.Utils
import java.sql._
import kx.c
import kx.c._
import kx.c.Flip
import scala.Array


object FakeEngine {
}

/**
 * Example of some engine.
 * 
 */
class SimulatorEngine extends Engine with LazyLogging {

  import TttsEngineMessages._
  import Engine._

  var resultStatus = false
  
  type KdbType = (Double, Double, Long, Boolean, Long)

  override def process(msg: TttsEngineMessage, isInTrade: Boolean): EngineType = {
    
    /*
     * Do Engine processing, create ResponseEngineFacadeTopicMessage (reply to FacadeMS)
     * 
     */ 

    // 1. Do some fake Engine processing here. Replace with real code.
//    val fraction = msg.asInstanceOf[ResponseEngineFacadeTopicMessage].payload.toDouble - msg.asInstanceOf[ResponseEngineFacadeTopicMessage].payload.toDouble.intValue
//    val signal = fraction match {
//      case x if(x < 0.2) => "BUY"
//      case x if(x > 0.8) => "SELL"
//      case _ => "HOLD"
//    }
    
    // 2. Create ResponseEngineFacadeTopicMessage

    // Generate unique message ID, timestamp and sequence number to be assigned to every message.
    val messageTraits = Utils.generateMessageTraits


    /*
     * - Assign unique message id and timestamp generated by Utils.generateMessageTraits.
     * - Pass along client, payload and sequenceNum from Engine message.
     * - Add signal field
     * - Return ResponseEngineFacadeTopicMessage or ResponseEngineServiceTopicMessage, depending on incoming message type.
     */ 
    msg match {
	    case x: ResponseStrategyFacadeTopicMessage => {
	       val payload = s"${x.payload} ==> ${play(x.signal, x.payload)}"
	       (ResponseEngineFacadeTopicMessage(messageTraits._1, ENGINE_RESPONSE_MESSAGE_TYPE, x.client, payload, messageTraits._2, x.sequenceNum, x.signal), resultStatus)
	    }
	    case x: ResponseStrategyServicesTopicMessage => {
	       val payload = s"${x.payload} ==> ${play(x.signal, x.payload)}"
	       (ResponseEngineServicesTopicMessage(messageTraits._1, ENGINE_RESPONSE_MESSAGE_TYPE, x.client, payload, messageTraits._2, x.sequenceNum, x.signal, x.serviceId), resultStatus)	      
	    }
	    case _ =>  {
	      logger.error("FakeEngine Received unsupported message type")
	      (msg, resultStatus)
	    }
    }

  }
  
  def play(signal: String, payload: String) = {
    val data = getEngineData()
    signal match {
      case "BUY" => if(!data._4) {
	        val comission = 10
	        val newPossize = ((data._2 - comission) / payload.toDouble).longValue
	        if(newPossize > 0) {
	            val newFunds = data._1 
		        val position =  newPossize * payload.toDouble
		        val newTransnum = data._3 + 1
		        val newBalance =  data._2 - position 
		        val newIntrade = true

		        val newData = (newFunds, newBalance, newTransnum, newIntrade, newPossize)
		        setEngineData(newData)

		        s"IN@$payload for [${position}]"
		        
	        } else {
	        	"margin call"
	        }
	      	} else {
	      	  "HOLD"
	      	}
      case "SELL" => if(data._4) {
	        val comission = 10
            val newFunds = data._1 
	        
	        val newTransnum = data._3 + 1
	        val newBalance =  data._5 * payload.toDouble - comission + data._2 
	        val newPossize = 0l
	        val newIntrade = false

	        val newData = (newFunds, newBalance, newTransnum, newIntrade, newPossize)
	        setEngineData(newData)

	        s"OUT@$payload"

        } else {
      	  "NO POSITION"
      	}
      case "HOLD" => "PASS"
      case _ => "Nothing"
    }
    
  }
  
  def getEngineData(): KdbType = {
      val conn: c = new c("localhost", 5555)
      val res = conn.k("select from engine")
      val tabres: Flip = res.asInstanceOf[Flip]
      val colNames = tabres.x
      val colData = tabres.y
      
      val funds: Double = (c.at(colData(0), 0)).asInstanceOf[Double]
      val balance: Double = (c.at(colData(1), 0)).asInstanceOf[Double]
      val transnum: Long = (c.at(colData(2), 0)).asInstanceOf[Long]
      val intrade: Boolean = (c.at(colData(3), 0)).asInstanceOf[Boolean]
      val possize: Long = (c.at(colData(4), 0)).asInstanceOf[Long]
//      val kdb: KdbType = (c.at(colData(0), 0).asInstanceOf[Double], c.at(colData(1), 0).asInstanceOf[Double], c.at(colData(2), 0).asInstanceOf[Int], c.at(colData(3), 0).asInstanceOf[Boolean], c.at(colData(4), 0).asInstanceOf[Int])
      val kdb: KdbType = (funds, balance, transnum, intrade, possize)
      logger.info("^^^^^^^^^^^^ data = {}", kdb)
      conn close
      
      kdb
    
  }

  def setEngineData(data: KdbType) = {
      val conn: c = new c("localhost", 5555)
//      val res = conn.k(s"update engine set funds=${data._1}, balance=${data._2}, transnum=${data._3}, intrade=${data._4}, possize=${data._5}")
      
      var intradeStr = "0b"
      if(data._4) {
        intradeStr = "1b"
      }
      
      conn.k(s"engine:update funds:${data._1},balance:${data._2},transnum:${data._3},intrade:${intradeStr},possize:${data._5} from engine")

//    try {
//
//      val res = conn.k("select from engine")
//      val tabres: Flip = res.asInstanceOf[Flip]
//      val colNames = tabres.x
//      val colData = tabres.y
//
//      
////      val newColnames: Array[String] = Array("funds", "balance", "transnum", "intrade", "possize")
////      val newData: Array[Object] = Array(data._1.asInstanceOf[Object], data._2.asInstanceOf[Object], data._3.asInstanceOf[Object], data._4.asInstanceOf[Object], data._5.asInstanceOf[Object])
////      val newTabres: Flip = new Flip(new Dict(newColnames, newData))
////      val updStatement: Array[Object] = Array(".u.upd", "engine", newTabres)
////      conn.k(updStatement)
//
//      val newColnames = Array("funds", "balance", "transnum", "intrade", "possize")
//      val newData = Array(data._1, data._2, data._3, data._4, data._5)
//      val newTabres = new Flip(new Dict(newColnames, newData))
//      val updStatement = Array(".u.upd", "engine", newTabres)
//      conn.k(updStatement)
//      
//      
////      conn.ks(updStatement)
//      getEngineData()	
//      
//      c.set(colData(0), 0, data._1)
//      c.set(colData(1), 0, data._2)
//      c.set(colData(2), 0, data._3)
//      c.set(colData(3), 0, data._4)
//      c.set(colData(4), 0, data._5)
//      
//
//	} catch {
//	  case e: Throwable => logger.error("################## setEngineData Error updating engine: " + e)
//	  e.printStackTrace()
//	}
  
      getEngineData()	
      conn close
      
  }
  
  
}
  
