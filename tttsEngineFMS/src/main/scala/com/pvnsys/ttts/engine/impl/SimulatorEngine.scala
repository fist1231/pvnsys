package com.pvnsys.ttts.engine.impl

import com.pvnsys.ttts.engine.messages.TttsEngineMessages
import com.typesafe.scalalogging.slf4j.LazyLogging
import com.pvnsys.ttts.engine.util.Utils

object FakeEngine {
}

/**
 * Example of some engine.
 * 
 */
class SimulatorEngine extends Engine with LazyLogging {

  import TttsEngineMessages._

  override def process(msg: TttsEngineMessage) = {
    
    /*
     * Do Engine processing, create ResponseEngineFacadeTopicMessage (reply to FacadeMS)
     * 
     */ 
    
    // 1. Do some fake Engine processing here. Replace with real code.
    val fraction = msg.asInstanceOf[ResponseEngineFacadeTopicMessage].payload.toDouble - msg.asInstanceOf[ResponseEngineFacadeTopicMessage].payload.toDouble.intValue
    val signal = fraction match {
      case x if(x < 0.2) => "BUY"
      case x if(x > 0.8) => "SELL"
      case _ => "HOLD"
    }
    
    // 2. Create ResponseEngineFacadeTopicMessage

    // Generate unique message ID, timestamp and sequence number to be assigned to every message.
    val messageTraits = Utils.generateMessageTraits


    /*
     * - Assign unique message id and timestamp generated by Utils.generateMessageTraits.
     * - Pass along client, payload and sequenceNum from Engine message.
     * - Add signal field
     * - Return ResponseEngineFacadeTopicMessage or ResponseEngineServiceTopicMessage, depending on incoming message type.
     */ 
    msg match {
	    case x: ResponseEngineFacadeTopicMessage => {
	       ResponseEngineFacadeTopicMessage(messageTraits._1, ENGINE_RESPONSE_MESSAGE_TYPE, x.client, x.payload, messageTraits._2, x.sequenceNum, signal)
	    }
	    case x: ResponseEngineServicesTopicMessage => {
	       ResponseEngineServicesTopicMessage(messageTraits._1, ENGINE_RESPONSE_MESSAGE_TYPE, x.client, x.payload, messageTraits._2, x.sequenceNum, signal, x.serviceId)	      
	    }
	    case _ =>  {
	      logger.error("FakeEngine Received unsupported message type")
	      msg
	    }
    }

  }

}
  
