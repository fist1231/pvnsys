package com.pvnsys.ttts.engine.impl

import akka.actor.{Actor, ActorLogging, Props, PoisonPill, ActorRef}
import com.pvnsys.ttts.engine.messages.TttsEngineMessages
import com.pvnsys.ttts.engine.util.Utils
import java.sql._
import kx.c
import kx.c._
import kx.c.Flip
import scala.Array
import com.pvnsys.ttts.engine.db.ReadKdbActor
import com.pvnsys.ttts.engine.db.WriteKdbActor
import akka.util.Timeout
import scala.concurrent.duration._
import akka.pattern.ask
import scala.concurrent.Future
import scala.concurrent.ExecutionContext.Implicits.global
import scala.util.{Failure, Success}



object SimulatorEngineActor {

  import TttsEngineMessages._
  /*
   * Engine table row Tuple: 
   *   funds - initial balance; 
   *   balance - current balance; 
   *   transnum - number of transactions; 
   *   intrade - is trade in progress; 
   *   possize - trade in progress position size
   *   
   *   engine:([]funds:`float$();balance:`float$();transnum:`long$();intrade:`boolean$();possize:`long$())
   */ 
  type EngineKdbType = (Double, Double, Long, Boolean, Long)
  
  // trade:([]time:`time$();sym:`symbol$();price:`float$();size:`long$();oper:`symbol$();cost:`float$()) 
  type TransactionKdbType = (String, String, Double, Long, String, Double)
  
  sealed trait SimulatorEngineMessages
  case class StartSimulatorEngineMessage(message: TttsEngineMessage, serviceId: String) extends SimulatorEngineMessages
  case object StopSimulatorEngineMessage extends SimulatorEngineMessages
  case class SimulatorEngineResponseMessage(message: TttsEngineMessage) extends SimulatorEngineMessages

}

/**
 * Example of some engine.
 * 
 */
class SimulatorEngineActor extends Actor with Engine with ActorLogging {

  import TttsEngineMessages._
  import SimulatorEngineActor._
  import ReadKdbActor._
  import WriteKdbActor._
  
  override def receive = {
    case m: StartSimulatorEngineMessage => {
      log.debug("SimulatorEngineActor received StartSimulatorEngineMessage: {}", m)
	  val client = sender()
	  val host = self
      val result = execute(client, host, m.message, m.serviceId)
//      client ! result
      
    }
    case StopSimulatorEngineMessage => {
      log.debug("SimulatorEngineActor received StopSimulatorEngineMessage")
      context stop self
    }
  }  
  
  
  override def process(msg: TttsEngineMessage, serviceId: String): TttsEngineMessage = {
    msg
  }
  
  
/*
 * Do Engine processing, create ResponseEngineFacadeTopicMessage (reply to FacadeMS)
 * 
 */ 
  def execute(client: ActorRef, host: ActorRef, msg: TttsEngineMessage, serviceId: String) = {
    
//    var response: TttsEngineMessage = msg 
    // Generate unique message ID, timestamp and sequence number to be assigned to every message.
    val messageTraits = Utils.generateMessageTraits

    /*
     * - Assign unique message id and timestamp generated by Utils.generateMessageTraits.
     * - Pass along client, payload and sequenceNum from Engine message.
     * - Add signal field
     * - Return ResponseEngineFacadeTopicMessage or ResponseEngineServiceTopicMessage, depending on incoming message type.
     */ 
    msg match {
	    case x: ResponseStrategyFacadeTopicMessage => {
	      
	        x.payload match {
		          case Some(payload) => {
			    	val engineResult: Future[String] = play(serviceId, x.signal, payload)
			    	engineResult.onComplete {
			    	  case Success(result) => {
					       val payloadStr = s"${result}"
					       val payloadRsp = EnginePayload(payload.datetime, payload.ticker, payload.open, payload.high, payload.low, payload.close, payload.volume, payload.wap, payload.size, payloadStr)
					       val response = ResponseEngineFacadeTopicMessage(messageTraits._1, ENGINE_RESPONSE_MESSAGE_TYPE, x.client, Some(payloadRsp), messageTraits._2, x.sequenceNum, x.signal)
			    	       log.debug("Execute ResponseStrategyFacadeTopicMessage:client: {} ; message: {}", client, response)
					       client ! response
					       host ! StopSimulatorEngineMessage
			    	  }
			    	  case Failure(error) => {
			    	    log.error("SimulatorEngine process method error: {}", error.getMessage())
			    	  }
			    	}
	          }
	          case None => 
	        }
	    }
	    case x: ResponseStrategyServicesTopicMessage => {

	        x.payload match {
		          case Some(payload) => {
			    	val engineResult: Future[String] = play(serviceId, x.signal, payload)
			    	engineResult.onComplete {
			    	  case Success(result) => {
					       val payloadStr = s"${result}"
					       val payloadRsp = EnginePayload(payload.datetime, payload.ticker, payload.open, payload.high, payload.low, payload.close, payload.volume, payload.wap, payload.size, payloadStr)
					       val response = ResponseEngineServicesTopicMessage(messageTraits._1, ENGINE_RESPONSE_MESSAGE_TYPE, x.client, Some(payloadRsp), messageTraits._2, x.sequenceNum, x.signal, x.serviceId)	 
			    	       log.debug("Execute ResponseStrategyServicesTopicMessage: {} ; message: {}", client, response)
					       client ! response
					       host ! StopSimulatorEngineMessage
			    	  }
			    	  case Failure(error) => {
			    	    log.error("SimulatorEngine process method error: {}", error.getMessage())
			    	  }
			    	}
	          }
	          case None => 
	        }
	    }
	    case _ =>  {
	      log.error("SimulatorEngine Received unsupported message type")
	    }
    }
//    response
  }
  
  def play(serviceId: String, signal: String, payload: StrategyPayload): Future[String] = {
//    val data = getEngineData()
    
	implicit val timeout = Timeout(2 seconds)
//	implicit val executor = context.system.dispatcher

    val readKdbActor = context.actorOf(ReadKdbActor.props(serviceId))
    
    (readKdbActor ? ReadKdbMessage).mapTo[ReadKdbResultMessage] map {resultMessage =>
      	
	//    val data = (0f, 0f, 0l, true, 0l)
	    
        val data = resultMessage.result 
      
	    signal match {
	      case "BUY" => if(!data._4) {
		        val comission = 10
		        val newPossize = ((data._2 - comission) / payload.close).longValue
		        if(newPossize > 0) {
		            val newFunds = data._1 
			        val position =  newPossize * payload.close + comission
			        val newTransnum = data._3 + 1
			        val newBalance =  data._2 - position 
			        val newIntrade = true
	
			        val newData = (newFunds, newBalance, newTransnum, newIntrade, newPossize)
			        writeEngineData(serviceId, newData)

			        /*
			         * trade:([]time:`time$();sym:`symbol$();price:`float$();size:`int$();oper:`symbol$();cost:`float$())
			         */
			        
			        val transactionData = ("09:30:00.000", "AA", payload.close, newPossize, "buy", -1 * position)
			        writeTransactionData(serviceId, transactionData)
			        s"IN@$payload for [${position}]"
			        
		        } else {
		        	"margin call"
		        }
		      	} else {
		      	  "HOLD"
		      	}
	      case "SELL" => if(data._4) {
		        val comission = 10
	            val newFunds = data._1 
		        
		        val newTransnum = data._3 + 1
		        val sellProceeds = data._5 * payload.close - comission
		        val newBalance =  data._5 * payload.close - comission + data._2 
		        val newPossize = 0l
		        val newIntrade = false
	
		        val newData = (newFunds, newBalance, newTransnum, newIntrade, newPossize)
		        writeEngineData(serviceId, newData)
	
		        val transactionData = ("15:59:00.000", "AA", payload.close, newPossize, "sell", sellProceeds)
		        writeTransactionData(serviceId, transactionData)
		        s"OUT@$payload"
	
	        } else {
	      	  "NO POSITION"
	      	}
	      case "HOLD" => "PASS"
	      case _ => "Nothing"
	    }
	}
    
  }

  def writeEngineData(serviceId: String, data: EngineKdbType): Unit = {

    val writeKdbActor = context.actorOf(WriteKdbActor.props(serviceId))
    writeKdbActor ! WriteEngineKdbMessage(data)
    writeKdbActor ! StopWriteKdbActor
  
  }  

  def writeTransactionData(serviceId: String, data: TransactionKdbType): Unit = {

    val writeKdbActor = context.actorOf(WriteKdbActor.props(serviceId))
    writeKdbActor ! WriteTransactionKdbMessage(data)
    writeKdbActor ! StopWriteKdbActor
  
  }  
  
//  def getEngineData(): KdbType = {
//      val conn: c = new c(Configuration.kdbHost, Configuration.kdbPort)
//      val res = conn.k("select from engine")
//      val tabres: Flip = res.asInstanceOf[Flip]
//      val colNames = tabres.x
//      val colData = tabres.y
//      
//      val funds: Double = (c.at(colData(0), 0)).asInstanceOf[Double]
//      val balance: Double = (c.at(colData(1), 0)).asInstanceOf[Double]
//      val transnum: Long = (c.at(colData(2), 0)).asInstanceOf[Long]
//      val intrade: Boolean = (c.at(colData(3), 0)).asInstanceOf[Boolean]
//      val possize: Long = (c.at(colData(4), 0)).asInstanceOf[Long]
////      val kdb: KdbType = (c.at(colData(0), 0).asInstanceOf[Double], c.at(colData(1), 0).asInstanceOf[Double], c.at(colData(2), 0).asInstanceOf[Int], c.at(colData(3), 0).asInstanceOf[Boolean], c.at(colData(4), 0).asInstanceOf[Int])
//      val kdb: KdbType = (funds, balance, transnum, intrade, possize)
//      log.info("^^^^^^^^^^^^ data = {}", kdb)
//      conn close
//      
//      kdb
//    
//  }

//  def setEngineData(data: KdbType) = {
//      val conn: c = new c(Configuration.kdbHost, Configuration.kdbPort)
////      val res = conn.k(s"update engine set funds=${data._1}, balance=${data._2}, transnum=${data._3}, intrade=${data._4}, possize=${data._5}")
//      
//      var intradeStr = "0b"
//      if(data._4) {
//        intradeStr = "1b"
//      }
//      
//      conn.k(s"engine:update funds:${data._1},balance:${data._2},transnum:${data._3},intrade:${intradeStr},possize:${data._5} from engine")
//
////    try {
////
////      val res = conn.k("select from engine")
////      val tabres: Flip = res.asInstanceOf[Flip]
////      val colNames = tabres.x
////      val colData = tabres.y
////
////      
//////      val newColnames: Array[String] = Array("funds", "balance", "transnum", "intrade", "possize")
//////      val newData: Array[Object] = Array(data._1.asInstanceOf[Object], data._2.asInstanceOf[Object], data._3.asInstanceOf[Object], data._4.asInstanceOf[Object], data._5.asInstanceOf[Object])
//////      val newTabres: Flip = new Flip(new Dict(newColnames, newData))
//////      val updStatement: Array[Object] = Array(".u.upd", "engine", newTabres)
//////      conn.k(updStatement)
////
////      val newColnames = Array("funds", "balance", "transnum", "intrade", "possize")
////      val newData = Array(data._1, data._2, data._3, data._4, data._5)
////      val newTabres = new Flip(new Dict(newColnames, newData))
////      val updStatement = Array(".u.upd", "engine", newTabres)
////      conn.k(updStatement)
////      
////      
//////      conn.ks(updStatement)
////      getEngineData()	
////      
////      c.set(colData(0), 0, data._1)
////      c.set(colData(1), 0, data._2)
////      c.set(colData(2), 0, data._3)
////      c.set(colData(3), 0, data._4)
////      c.set(colData(4), 0, data._5)
////      
////
////	} catch {
////	  case e: Throwable => log.error("################## setEngineData Error updating engine: " + e)
////	  e.printStackTrace()
////	}
//      conn close
//      
//  }
  
  
}
  
