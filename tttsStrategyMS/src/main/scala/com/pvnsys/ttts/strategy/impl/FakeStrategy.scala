package com.pvnsys.ttts.strategy.impl

import com.pvnsys.ttts.strategy.messages.TttsStrategyMessages
import com.typesafe.scalalogging.slf4j.LazyLogging
import com.pvnsys.ttts.strategy.util.Utils

object FakeStrategy {
}

/**
 * Example of some strategy.
 * 
 */
class FakeStrategy extends Strategy with LazyLogging {

  import TttsStrategyMessages._

  override def process(msg: TttsStrategyMessage) = {
    
    /*
     * Do Strategy processing, create ResponseStrategyFacadeTopicMessage (reply to FacadeMS)
     * 
     */ 
    
    // 1. Do some fake Strategy processing here. Replace with real code.
    val fraction = msg.asInstanceOf[ResponseFeedFacadeTopicMessage].payload.toDouble - msg.asInstanceOf[ResponseFeedFacadeTopicMessage].payload.toDouble.intValue
    val signal = fraction match {
      case x if(x < 0.2) => "BUY"
      case x if(x > 0.8) => "SELL"
      case _ => "HOLD"
    }
    
    // 2. Create ResponseStrategyFacadeTopicMessage

    // Generate unique message ID, timestamp and sequence number to be assigned to every message.
    val messageTraits = Utils.generateMessageTraits


    /*
     * - Assign unique message id and timestamp generated by Utils.generateMessageTraits.
     * - Pass along client, payload and sequenceNum from Feed message.
     * - Add signal field
     * - Return ResponseStrategyFacadeTopicMessage or ResponseStrategyServiceTopicMessage, depending on incoming message type.
     */ 
    msg match {
	    case x: ResponseFeedFacadeTopicMessage => {
	       ResponseStrategyFacadeTopicMessage(messageTraits._1, STRATEGY_RESPONSE_MESSAGE_TYPE, x.client, x.payload, messageTraits._2, x.sequenceNum, signal)
	    }
	    case x: ResponseFeedServicesTopicMessage => {
	       ResponseStrategyServicesTopicMessage(messageTraits._1, STRATEGY_RESPONSE_MESSAGE_TYPE, x.client, x.payload, messageTraits._2, x.sequenceNum, signal, x.serviceId)	      
	    }
	    case _ =>  {
	      logger.error("FakeStrategy Received unsupported message type")
	      msg
	    }
    }

  }

}
  
