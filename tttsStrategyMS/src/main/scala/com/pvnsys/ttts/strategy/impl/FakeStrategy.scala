package com.pvnsys.ttts.strategy.impl

import com.pvnsys.ttts.strategy.messages.TttsStrategyMessages
import com.typesafe.scalalogging.slf4j.LazyLogging
import com.pvnsys.ttts.strategy.util.Utils
import scala.concurrent._
import ExecutionContext.Implicits.global

object FakeStrategy {
}

/**
 * Example of some strategy.
 * 
 */
class FakeStrategy extends Strategy with LazyLogging {

  import TttsStrategyMessages._

  override def applyStrategy(serviceId: String, message: TttsStrategyMessage): TttsStrategyMessage = {
    
    /*
     * Do Strategy processing, create ResponseStrategyFacadeTopicMessage (reply to FacadeMS)
     * 
     */ 
    
    val feedPayload = message match {
      case x: ResponseFeedFacadeTopicMessage => x.payload 
      case x: ResponseFeedServicesTopicMessage => x.payload 
      case _ => None
    }
    
    val signal = feedPayload match {
      case Some(payload) => {
		   	val fraction = payload.close - payload.close.intValue
		    // 1. Do some fake Strategy processing here. Replace with real code.
		//    val fraction = msg.asInstanceOf[ResponseFeedFacadeTopicMessage].payload.toDouble - msg.asInstanceOf[ResponseFeedFacadeTopicMessage].payload.toDouble.intValue
		    val signal = fraction match {
		      case x if(x < 0.2) => "BUY"
		      case x if(x > 0.8) => "SELL"
		      case _ => "HOLD"
		    }
		   	signal
        
      }
      case None => "UNKNOWN"
    }
    
    // 2. Create ResponseStrategyFacadeTopicMessage

    // Generate unique message ID, timestamp and sequence number to be assigned to every message.
    val messageTraits = Utils.generateMessageTraits


    /*
     * - Assign unique message id and timestamp generated by Utils.generateMessageTraits.
     * - Pass along client, payload and sequenceNum from Feed message.
     * - Add signal field
     * - Return ResponseStrategyFacadeTopicMessage or ResponseStrategyServiceTopicMessage, depending on incoming message type.
     */ 
    message match {
	    case x: ResponseFeedFacadeTopicMessage => {
	       x.payload match {
	         case Some(feepPayload) => {
	        	 val strategyPayload = StrategyPayload(feepPayload.datetime, feepPayload.ticker, feepPayload.open, feepPayload.high, feepPayload.low, feepPayload.close, feepPayload.volume, feepPayload.wap, feepPayload.size, "strategy response payload here", 0.00, 0.00, 0.00)
	        	 ResponseStrategyFacadeTopicMessage(messageTraits._1, STRATEGY_RESPONSE_MESSAGE_TYPE, x.client, Some(strategyPayload), messageTraits._2, x.sequenceNum, signal)
	           
	         }
	         case None => message
	       }
	      
	    }
	    case x: ResponseFeedServicesTopicMessage => {
	       x.payload match {
	         case Some(feepPayload) => {
	        	 val strategyPayload = StrategyPayload(feepPayload.datetime, feepPayload.ticker, feepPayload.open, feepPayload.high, feepPayload.low, feepPayload.close, feepPayload.volume, feepPayload.wap, feepPayload.size, "strategy response payload here", 0.00, 0.00, 0.00)
	        	 ResponseStrategyServicesTopicMessage(messageTraits._1, STRATEGY_RESPONSE_MESSAGE_TYPE, x.client, Some(strategyPayload), messageTraits._2, x.sequenceNum, signal, x.serviceId)	      
	         }
	         case None => message
	       }
	    }
	    case _ =>  {
	      logger.error("FakeStrategy Received unsupported message type")
	      message
	    }
    }

  }

}
  
