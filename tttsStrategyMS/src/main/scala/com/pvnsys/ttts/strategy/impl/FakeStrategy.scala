package com.pvnsys.ttts.strategy.impl

import com.pvnsys.ttts.strategy.messages.TttsStrategyMessages
import com.typesafe.scalalogging.slf4j.LazyLogging
import com.pvnsys.ttts.strategy.util.Utils
import scala.concurrent._
import ExecutionContext.Implicits.global

object FakeStrategy {
}

/**
 * Example of some strategy.
 * 
 */
class FakeStrategy extends Strategy with LazyLogging {

  import TttsStrategyMessages._

  override def process(serviceId: String, payload: FeedPayload): Future[String] = {
    
    /*
     * Do Strategy processing, create ResponseStrategyFacadeTopicMessage (reply to FacadeMS)
     * 
     */ 
   	val fraction = payload.close - payload.close.intValue
    // 1. Do some fake Strategy processing here. Replace with real code.
//    val fraction = msg.asInstanceOf[ResponseFeedFacadeTopicMessage].payload.toDouble - msg.asInstanceOf[ResponseFeedFacadeTopicMessage].payload.toDouble.intValue
    val signal = fraction match {
      case x if(x < 0.2) => "BUY"
      case x if(x > 0.8) => "SELL"
      case _ => "HOLD"
    }
   	
   	val result: Future[String] = Future { signal }
   	result
    
//    // 2. Create ResponseStrategyFacadeTopicMessage
//
//    // Generate unique message ID, timestamp and sequence number to be assigned to every message.
//    val messageTraits = Utils.generateMessageTraits
//
//
//    /*
//     * - Assign unique message id and timestamp generated by Utils.generateMessageTraits.
//     * - Pass along client, payload and sequenceNum from Feed message.
//     * - Add signal field
//     * - Return ResponseStrategyFacadeTopicMessage or ResponseStrategyServiceTopicMessage, depending on incoming message type.
//     */ 
//    msg match {
//	    case x: ResponseFeedFacadeTopicMessage => {
//	       x.payload match {
//	         case Some(feepPayload) => {
//	        	 val strategyPayload = StrategyPayload(feepPayload.datetime, feepPayload.ticker, feepPayload.open, feepPayload.high, feepPayload.low, feepPayload.close, feepPayload.volume, feepPayload.wap, feepPayload.size, "strategy response payload here")
//	        	 ResponseStrategyFacadeTopicMessage(messageTraits._1, STRATEGY_RESPONSE_MESSAGE_TYPE, x.client, Some(strategyPayload), messageTraits._2, x.sequenceNum, signal)
//	           
//	         }
//	         case None => msg
//	       }
//	      
//	    }
//	    case x: ResponseFeedServicesTopicMessage => {
//	       x.payload match {
//	         case Some(feepPayload) => {
//	        	 val strategyPayload = StrategyPayload(feepPayload.datetime, feepPayload.ticker, feepPayload.open, feepPayload.high, feepPayload.low, feepPayload.close, feepPayload.volume, feepPayload.wap, feepPayload.size, "strategy response payload here")
//	        	 ResponseStrategyServicesTopicMessage(messageTraits._1, STRATEGY_RESPONSE_MESSAGE_TYPE, x.client, Some(strategyPayload), messageTraits._2, x.sequenceNum, signal, x.serviceId)	      
//	         }
//	         case None => msg
//	       }
//	    }
//	    case _ =>  {
//	      logger.error("FakeStrategy Received unsupported message type")
//	      msg
//	    }
//    }

  }

}
  
