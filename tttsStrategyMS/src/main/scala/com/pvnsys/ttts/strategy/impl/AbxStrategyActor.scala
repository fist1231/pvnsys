package com.pvnsys.ttts.strategy.impl

import akka.actor.{Actor, ActorLogging, Props, PoisonPill, ActorRef}
import com.pvnsys.ttts.strategy.messages.TttsStrategyMessages
import com.pvnsys.ttts.strategy.util.Utils
import java.sql._
import kx.c
import kx.c._
import kx.c.Flip
import scala.Array
import com.pvnsys.ttts.strategy.db.ReadKdbActor
import com.pvnsys.ttts.strategy.db.WriteKdbActor
import akka.util.Timeout
import scala.concurrent.duration._
import akka.pattern.ask
import scala.concurrent.Future
import scala.concurrent.ExecutionContext.Implicits.global
import scala.util.{Failure, Success}
import java.util.Date



object AbxStrategyActor {

  import TttsStrategyMessages._
  /*
   *   
   */ 
  type StrategyKdbType = (Double, Double, Long, Boolean, Long)
  
  // quotes:([]datetime:`timestamp$();sym:`symbol$();open:`float$();high:`float$();low:`float$();close:`float$();volume:`long$();wap:`float$();size:`long$()) 
  type TransactionKdbType = (String, String, Double, Double, Double, Double, Long, Double, Long)
  
  sealed trait AbxStrategyMessages
  case class StartAbxStrategyMessage(message: TttsStrategyMessage, serviceId: String) extends AbxStrategyMessages
  case object StopAbxStrategyMessage extends AbxStrategyMessages
  case class AbxStrategyResponseMessage(message: TttsStrategyMessage) extends AbxStrategyMessages

}

/**
 * abx strategy.
 * 
 */
class AbxStrategyActor extends Actor with Strategy with ActorLogging {

  import TttsStrategyMessages._
  import AbxStrategyActor._
  import WriteKdbActor._
  import ReadKdbActor._
  
  override def receive = {
    case m: StartAbxStrategyMessage => {
      log.debug("AbxStrategyActor received StartAbxStrategyMessage: {}", m)
	  val client = sender()
	  val host = self
      val result = execute(client, host, m.message, m.serviceId)
//      client ! result
      
    }
    case StopAbxStrategyMessage => {
      log.debug("AbxStrategyActor received StopAbxStrategyMessage")
      context stop self
    }
  }  
  
  
  override def process(msg: TttsStrategyMessage): TttsStrategyMessage = {
    msg
  }
  
  
/*
 * Do Strategy processing, create ResponseStrategyFacadeTopicMessage (reply to FacadeMS)
 * 
 */ 
  def execute(client: ActorRef, host: ActorRef, msg: TttsStrategyMessage, serviceId: String) = {
    
//    var response: TttsStrategyMessage = msg 
    // Generate unique message ID, timestamp and sequence number to be assigned to every message.
    val messageTraits = Utils.generateMessageTraits

    /*
     * - Assign unique message id and timestamp generated by Utils.generateMessageTraits.
     * - Pass along client, payload and sequenceNum from Strategy message.
     * - Add signal field
     * - Return ResponseStrategyFacadeTopicMessage or ResponseStrategyServiceTopicMessage, depending on incoming message type.
     */ 
    msg match {
	    case x: ResponseFeedFacadeTopicMessage => {
	      
	        x.payload match {
	          case Some(payload) => {
			    	val strategyResult: Future[String] = play(serviceId, payload)
			    	strategyResult.onComplete {
			    	  case Success(result) => {
					       val payloadStr = s"${result}"
					       val payloadRsp = StrategyPayload(payload.datetime, "abx", payload.open, payload.high, payload.low, payload.close, payload.volume, payload.wap, payload.size, payloadStr)
					       val response = ResponseStrategyFacadeTopicMessage(messageTraits._1, STRATEGY_RESPONSE_MESSAGE_TYPE, x.client, Some(payloadRsp), messageTraits._2, x.sequenceNum, result)
			    	       log.debug("Execute ResponseStrategyFacadeTopicMessage:client: {} ; message: {}", client, response)
					       client ! response
					       host ! StopAbxStrategyMessage
			    	  }
			    	  case Failure(error) => {
			    	    log.error("AbxStrategy process method error: {}", error.getMessage())
			    	  }
			    	}
	          }
	          case None => 
	        }
	    }
	    case x: ResponseFeedServicesTopicMessage => {

	        x.payload match {
	          case Some(payload) => {
			    	val strategyResult = play(serviceId, payload)
			    	strategyResult.onComplete {
			    	  case Success(result) => {
					       val payloadStr = s"${result}"
					       val payloadRsp = StrategyPayload(payload.datetime, "abx", payload.open, payload.high, payload.low, payload.close, payload.volume, payload.wap, payload.size, payloadStr)
					       val response = ResponseStrategyServicesTopicMessage(messageTraits._1, STRATEGY_RESPONSE_MESSAGE_TYPE, x.client, Some(payloadRsp), messageTraits._2, x.sequenceNum, result, x.serviceId)	 
			    	       log.debug("Execute ResponseStrategyServicesTopicMessage: {} ; message: {}", client, response)
					       client ! response
					       host ! StopAbxStrategyMessage
			    	  }
			    	  case Failure(error) => {
			    	    log.error("AbxStrategy process method error: {}", error.getMessage())
			    	  }
			    	}
	          }
	          case None => 
	        }
	    }
	    case _ =>  {
	      log.error("AbxStrategy Received unsupported message type")
	    }
    }
//    response
  }
  
  def play(serviceId: String, payload: FeedPayload): Future[String] = {
//    val data = getStrategyData()
    
	implicit val timeout = Timeout(2 seconds)
//	implicit val executor = context.system.dispatcher

    val readKdbActor = context.actorOf(ReadKdbActor.props(serviceId))
    
    (readKdbActor ? ReadKdbMessage).mapTo[ReadKdbResultMessage] map {resultMessage =>
      	
	//    val data = (0f, 0f, 0l, true, 0l)
	    
        val data = resultMessage.result 
      
	    data._1 match {
	      case 5000.00 => {

		    	val inputSdf = new java.text.SimpleDateFormat("yyyy-MM-dd HH:mm:ss")
		    	val inputDate = inputSdf.parse(payload.datetime)
		    	val outputSdf = new java.text.SimpleDateFormat("yyyy.MM.dd'T'HH:mm:ss.SSS")
		    	val outputDateStr = outputSdf.format(inputDate)
		    	
	            val data = (outputDateStr, payload.ticker, payload.open, payload.high, payload.low, payload.close, payload.volume, payload.wap, payload.size)
		        writeQuotesData(serviceId, data)
		        "HOLD"
	      }
	      case _ => "PASS"
	    }
	}
    
  }

  def writeStrategyData(serviceId: String, data: StrategyKdbType): Unit = {

    val writeKdbActor = context.actorOf(WriteKdbActor.props(serviceId))
    writeKdbActor ! WriteStrategyKdbMessage(data)
    writeKdbActor ! StopWriteKdbActor
  
  }  

  def writeQuotesData(serviceId: String, data: TransactionKdbType): Unit = {

    val writeKdbActor = context.actorOf(WriteKdbActor.props(serviceId))
    writeKdbActor ! WriteTransactionKdbMessage(data)
    writeKdbActor ! StopWriteKdbActor
  
  }  
  
}
  
