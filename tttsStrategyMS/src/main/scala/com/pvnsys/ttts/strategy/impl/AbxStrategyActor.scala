package com.pvnsys.ttts.strategy.impl

import akka.actor.{Actor, ActorLogging, Props, PoisonPill, ActorRef}
import com.pvnsys.ttts.strategy.messages.TttsStrategyMessages
import com.pvnsys.ttts.strategy.util.Utils
import java.sql._
import kx.c
import kx.c._
import kx.c.Flip
import scala.Array
import com.pvnsys.ttts.strategy.db.ReadKdbActor
import com.pvnsys.ttts.strategy.db.WriteKdbActor
import akka.util.Timeout
import scala.concurrent.duration._
import akka.pattern.ask
import scala.concurrent.Future
import scala.concurrent.ExecutionContext.Implicits.global
import scala.util.{Failure, Success}
import java.util.Date



object AbxStrategyActor {

  import TttsStrategyMessages._
  /*
   *   
   */ 
  type StrategyKdbType = (Double, Double, Long, Boolean, Long)

//  type QuotesKdbType = (Option[Double], Option[Double], Option[Double], Option[Double], Option[Double], Option[Double])
  
  // quotes:([]datetime:`timestamp$();sym:`symbol$();open:`float$();high:`float$();low:`float$();close:`float$();volume:`long$();wap:`float$();size:`long$()) 
  type TransactionKdbType = (String, String, Double, Double, Double, Double, Long, Double, Long)
  
  sealed trait AbxStrategyMessages
  case class StartAbxStrategyMessage(message: TttsStrategyMessage, serviceId: String) extends AbxStrategyMessages
  case object StopAbxStrategyMessage extends AbxStrategyMessages
  case class AbxStrategyResponseMessage(message: TttsStrategyMessage) extends AbxStrategyMessages

}

/**
 * abx strategy.
 * 
 */
class AbxStrategyActor extends Actor with Strategy with ActorLogging {

  import TttsStrategyMessages._
  import AbxStrategyActor._
  import WriteKdbActor._
  import ReadKdbActor._
  

  /*
   * ################################# Strategy business logic goes here #################################################
   */
  
  override def process(serviceId: String, payload: FeedPayload): Future[String] = {
//    val data = getQuotesData()
    
	implicit val timeout = Timeout(2 seconds)
    val readKdbActor = context.actorOf(ReadKdbActor.props(serviceId))
    
    (readKdbActor ? ReadKdbMessage).mapTo[ReadKdbResultMessage] map {resultMessage =>
      	
        val data = resultMessage.result 
		val l2h: Double = data(0).getOrElse(0.00)
		val l2l: Double = data(1).getOrElse(0.00)
		val l2c: Double = data(2).getOrElse(0.00)
		val l1h: Double = data(3).getOrElse(0.00)
		val l1l: Double = data(4).getOrElse(0.00)
		val l1c: Double = data(5).getOrElse(0.00)
		val maxHigh: Double = data(6).getOrElse(0.00)

    	val inputSdf = new java.text.SimpleDateFormat("yyyy-MM-dd HH:mm:ss")
    	val inputDate = inputSdf.parse(payload.datetime)
    	val outputSdf = new java.text.SimpleDateFormat("yyyy.MM.dd'T'HH:mm:ss.SSS")
    	val outputDateStr = outputSdf.format(inputDate)
    	
        // Store Feed Quote to Quotes table
    	val writeData = (outputDateStr, payload.ticker, payload.open, payload.high, payload.low, payload.close, payload.volume, payload.wap, payload.size)
        writeQuotesData(serviceId, writeData)
		
		
		if(l2h != 0.00 && l2l != 0.00 && l2c != 0.00 && l1h != 0.00 && l1l != 0.00 && l1c != 0.00 && maxHigh != 0.00) {
		  /*
		   * Close > Prev. high - buy; Close < Prev. Low - sell. ==> No bueno, lost 5k over 200 trades.
		   */
//		  if(l1c > l2h) {
		  
		  /*
		   * Close > Last 10 max(High) - Buy; Close < Prev. Low - Sell
		   * 
		   */
		  if(l1c > maxHigh) {
		    "BUY"
		  } else if(l1c < l2l) {
		    "SELL"
		  } else {
		    "HOLD"
		  }
		} else {
		  "NOT ENOUGH DATA"
		}
        
	}
    
  }
  /*
   * ################################# Strategy business logic ends here #################################################
   */
  
  
  override def receive = {
    case m: StartAbxStrategyMessage => {
      log.debug("AbxStrategyActor received StartAbxStrategyMessage: {}", m)
	  val client = sender()
	  val host = self
      val result = execute(client, host, m.message, m.serviceId)
//      client ! result
      
    }
    case StopAbxStrategyMessage => {
      log.debug("AbxStrategyActor received StopAbxStrategyMessage")
      context stop self
    }
  }  
  
  
/*
 * Do Strategy processing, create ResponseStrategyFacadeTopicMessage (reply to FacadeMS)
 * 
 */ 
  private def execute(client: ActorRef, host: ActorRef, msg: TttsStrategyMessage, serviceId: String) = {
    
//    var response: TttsStrategyMessage = msg 
    // Generate unique message ID, timestamp and sequence number to be assigned to every message.
    val messageTraits = Utils.generateMessageTraits

    /*
     * - Assign unique message id and timestamp generated by Utils.generateMessageTraits.
     * - Pass along client, payload and sequenceNum from Strategy message.
     * - Add signal field
     * - Return ResponseStrategyFacadeTopicMessage or ResponseStrategyServiceTopicMessage, depending on incoming message type.
     */ 
    msg match {
	    case x: ResponseFeedFacadeTopicMessage => {
	      
	        x.payload match {
	          case Some(payload) => {
			    	val strategyResult: Future[String] = process(serviceId, payload)
			    	strategyResult.onComplete {
			    	  case Success(result) => {
					       val payloadStr = s"${result}"
					       val payloadRsp = StrategyPayload(payload.datetime, "abx", payload.open, payload.high, payload.low, payload.close, payload.volume, payload.wap, payload.size, payloadStr)
					       val response = ResponseStrategyFacadeTopicMessage(messageTraits._1, STRATEGY_RESPONSE_MESSAGE_TYPE, x.client, Some(payloadRsp), messageTraits._2, x.sequenceNum, result)
			    	       log.debug("Execute ResponseStrategyFacadeTopicMessage:client: {} ; message: {}", client, response)
					       client ! response
					       host ! StopAbxStrategyMessage
			    	  }
			    	  case Failure(error) => {
			    	    log.error("AbxStrategy process method error: {}", error.getMessage())
			    	  }
			    	}
	          }
	          case None => 
	        }
	    }
	    case x: ResponseFeedServicesTopicMessage => {

	        x.payload match {
	          case Some(payload) => {
			    	val strategyResult = process(serviceId, payload)
			    	strategyResult.onComplete {
			    	  case Success(result) => {
					       val payloadStr = s"${result}"
					       val payloadRsp = StrategyPayload(payload.datetime, "abx", payload.open, payload.high, payload.low, payload.close, payload.volume, payload.wap, payload.size, payloadStr)
					       val response = ResponseStrategyServicesTopicMessage(messageTraits._1, STRATEGY_RESPONSE_MESSAGE_TYPE, x.client, Some(payloadRsp), messageTraits._2, x.sequenceNum, result, x.serviceId)	 
			    	       log.debug("Execute ResponseStrategyServicesTopicMessage: {} ; message: {}", client, response)
					       client ! response
					       host ! StopAbxStrategyMessage
			    	  }
			    	  case Failure(error) => {
			    	    log.error("AbxStrategy process method error: {}", error.getMessage())
			    	  }
			    	}
	          }
	          case None => 
	        }
	    }
	    case _ =>  {
	      log.error("AbxStrategy Received unsupported message type")
	    }
    }
//    response
  }
  
  private def writeStrategyData(serviceId: String, data: StrategyKdbType): Unit = {

    val writeKdbActor = context.actorOf(WriteKdbActor.props(serviceId))
    writeKdbActor ! WriteStrategyKdbMessage(data)
    writeKdbActor ! StopWriteKdbActor
  
  }  

  private def writeQuotesData(serviceId: String, data: TransactionKdbType): Unit = {

    val writeKdbActor = context.actorOf(WriteKdbActor.props(serviceId))
    writeKdbActor ! WriteTransactionKdbMessage(data)
    writeKdbActor ! StopWriteKdbActor
  
  }  
  
}
  
